{"version":3,"file":"static/js/panelPreviewMTR.a81a5869.chunk.js","mappings":"+NAIMA,EAAoB,SAACC,GACvB,OAAO,IAAIC,SAAQ,SAACC,GAChB,IAAMC,EAAS,IAAIC,WACnBD,EAAOE,UAAY,kBAAMH,EAAQC,EAAOG,SACxCH,EAAOI,cAAcP,OAahBQ,EAAiB,mCAAG,WAAOC,GAAP,oFACvBC,EAAmBC,MAAMC,KAC3B,IAAIC,IACA,kBACOJ,EAAMK,iBAA6B,mBAD1C,OAEOL,EAAMK,iBAA6B,mBAErCC,KAAI,SAAAC,GAAE,OAAIA,EAAGC,aACbC,KAAK,IACLC,QAAQ,QAAS,MAE5BD,KAAK,IAXsB,SAaFE,SAASC,MAAMC,KAAK,0BAA2BZ,GAb7C,cAavBa,EAbuB,OAcvBC,EAAWb,MAAMC,KAClBQ,SAASK,cAA+B,kBAAmBC,MAAOF,SAAS,GAAqBG,WAC5FH,UAEHI,EAAmBL,EAAaM,QAA0B,SAACC,EAAKC,GAClE,IA5BkDC,EA4B5CC,GA5B4CD,EA4BGD,EAAVP,EA3BlCU,MAAK,SAAAC,GACd,IAAMC,EAAWD,EAAKE,MACtB,OACID,EAASE,WAAWnB,QAAQ,WAAY,QAAUa,EAAKO,QAAUH,EAASI,eAAiBR,EAAKQ,iBAyBpG,OAAIP,EACkBH,EAAII,MAAK,SAAAC,GACvB,IAAMM,EAAYN,EAAKE,MACjBK,EAAeT,EAAYI,MACjC,OACII,EAAUH,aAAeI,EAAaJ,YACtCG,EAAUD,eAAiBE,EAAaF,gBAG7BV,EAAMA,EAAIa,OAAOV,GAE7BH,IAEZ,IAjC0B,SAmChB7B,QAAQ2C,IACjBhB,EAAiBb,IAAjB,mCAAqB,WAAM8B,GAAN,iGAEPC,EAAgBD,EAAQR,MAAcU,IACtCC,EAAWC,UAAUC,UAAUC,SAAS,YAAcF,UAAUC,UAAUC,SAAS,UACnFC,EAAMJ,EACNF,EAAa3B,QAAQ,qBAAsB,MAC3CkC,mCAAA,UAAsCP,EAAaQ,MAAM,6BAAzD,aAAsC,EAA2C,IAN1E,SAQUC,MAAMH,GARhB,cAQPI,EARO,YASazD,EATb,UASqCyD,EAASxD,OAT9C,mEASPyD,EATO,yBAUNZ,EAAQa,QAAQvC,QAAQ,yBAAxB,oBAA+DsC,EAA/D,UAVM,yCAYbE,QAAQC,MAAR,MAZa,kBAaN,IAbM,0DAArB,wDApCyB,mFAAH","sources":["panels/save/export-diag/mtr-helper.ts"],"sourcesContent":["/**\n * Convert a `Blob` into Base64 data URL.\n * @param blob\n */\nconst readBlobAsDataURL = (blob: Blob): Promise<string> => {\n    return new Promise((resolve: (value: string) => void) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result as string);\n        reader.readAsDataURL(blob);\n    });\n};\n\nconst matchCssRuleByFontFace = (rules: CSSFontFaceRule[], font: FontFace): CSSFontFaceRule | undefined => {\n    return rules.find(rule => {\n        const cssStyle = rule.style as any;\n        return (\n            cssStyle.fontFamily.replace(/^\"(.+)\"$/, '$1') === font.family && cssStyle.unicodeRange === font.unicodeRange\n        );\n    });\n};\n\nexport const getBase64FontFace = async (svgEl: SVGSVGElement): Promise<string[]> => {\n    const uniqueCharacters = Array.from(\n        new Set(\n            [\n                ...svgEl.querySelectorAll<SVGElement>('.rmg-name__zh'),\n                ...svgEl.querySelectorAll<SVGElement>('.rmg-name__en'),\n            ]\n                .map(el => el.innerHTML)\n                .join('')\n                .replace(/[\\s]/g, '')\n        )\n    ).join('');\n\n    const fontFaceList = await document.fonts.load('80px GenYoMin TW, Vegur', uniqueCharacters);\n    const cssRules = Array.from(\n        (document.querySelector<HTMLLinkElement>('link#css_share')!.sheet!.cssRules[0] as CSSImportRule).styleSheet\n            .cssRules\n    ) as CSSFontFaceRule[];\n    const distinctCssRules = fontFaceList.reduce<CSSFontFaceRule[]>((acc, cur) => {\n        const matchedRule = matchCssRuleByFontFace(cssRules, cur);\n        if (matchedRule) {\n            const existence = acc.find(rule => {\n                const ruleStyle = rule.style as any;\n                const matchedStyle = matchedRule.style as any;\n                return (\n                    ruleStyle.fontFamily === matchedStyle.fontFamily &&\n                    ruleStyle.unicodeRange === matchedStyle.unicodeRange\n                );\n            });\n            return existence ? acc : acc.concat(matchedRule);\n        } else {\n            return acc;\n        }\n    }, []);\n\n    return await Promise.all(\n        distinctCssRules.map(async cssRule => {\n            try {\n                const ruleStyleSrc = (cssRule.style as any).src;\n                const isSafari = navigator.userAgent.includes('Safari') && !navigator.userAgent.includes('Chrome');\n                const url = isSafari\n                    ? ruleStyleSrc.replace(/^url\\(([\\S]+)\\).*$/, '$1')\n                    : process.env.PUBLIC_URL + '/styles/' + ruleStyleSrc.match(/^url\\(\"([\\S*]+)\"\\)/)?.[1];\n\n                const fontResp = await fetch(url);\n                const fontDataUri = await readBlobAsDataURL(await fontResp.blob());\n                return cssRule.cssText.replace(/src:[ \\w('\",\\-:/.)]+;/g, `src: url('${fontDataUri}'); `);\n            } catch (err) {\n                console.error(err);\n                return '';\n            }\n        })\n    );\n};\n"],"names":["readBlobAsDataURL","blob","Promise","resolve","reader","FileReader","onloadend","result","readAsDataURL","getBase64FontFace","svgEl","uniqueCharacters","Array","from","Set","querySelectorAll","map","el","innerHTML","join","replace","document","fonts","load","fontFaceList","cssRules","querySelector","sheet","styleSheet","distinctCssRules","reduce","acc","cur","font","matchedRule","find","rule","cssStyle","style","fontFamily","family","unicodeRange","ruleStyle","matchedStyle","concat","all","cssRule","ruleStyleSrc","src","isSafari","navigator","userAgent","includes","url","process","match","fetch","fontResp","fontDataUri","cssText","console","error"],"sourceRoot":""}